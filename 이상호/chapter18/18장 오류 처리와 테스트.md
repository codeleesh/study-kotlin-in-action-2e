# 18장 오류 처리와 테스트

- 코루틴 기반 비동기 코드의 오류 처리 및 테스트 전략

## 18.1 코루틴 내부에서 던져진 오류 처리

- 코루틴 빌더(launch, async) 내부에서 예외가 발생했을 때 예외가 어디서 어떻게 처리되는지를 보여줍니다.
- launch 내부에서 발생한 예외는 부모 코루틴으로 전파
- launch 내부에서 try-catch로 감싸도 잡히지 않음
- 예외를 잡으려면 launch에 람다 내부에 try-catch를 직접 넣어야 함

잘못된 예외 처리 예시
```kotlin
fun main(): Unit = runBlocking {
    try {
        launch {
            throw UnsupportedOperationException("Ouch!")
        }
    } catch (u: UnsupportedOperationException) {
        println("Handled $u") // 실행되지 않음
    }
}
```

올바른 예외 처리
```kotlin
fun main(): Unit = runBlocking {
    launch {
        try {
            throw UnsupportedOperationException("Ouch!")
        } catch (u: UnsupportedOperationException) {
            println("Handled $u")
        }
    }
}
```

async와 await의 예외 처리
- async로 생성한 코루틴의 예외는 즉시 던져지지 않고, await() 호출 시 예외가 발생
- 따라서 await() 호출 시 try-catch로 잡아야 함

```kotlin
fun main(): Unit = runBlocking {
    val myDeferredInt: Deferred<Int> = async {
        throw UnsupportedOperationException("Ouch!")
    }
    try {
        val v: Int = myDeferredInt.await()
    } catch (u: UnsupportedOperationException) {
        println("Handled: $u")
    }
}
```

## 18.2 코틀린 코루틴에서의 오류 전파
- 구조적 동시성에서 자식 코루틴의 실패가 부모 및 형제 코루틴에 어떤 영향을 미치는가를 설명

두 가지 방식
- 하나의 자식 실패로 전체가 실패
  - 한 자식의 실패가 부모에 전달되고 형제 코루틴들도 취소됨.
  - ex) UI 구성 등에서 오류가 전체에 영향을 주는 경우
- 자식의 실패가 전체 실패로 이어지지 않음
  - SupervisorJob 사용
  - 개별 실패는 부모나 형제에 영향을 주지 않음.
  - ex) 서버에서 독립적으로 실행되는 백그라운드 작업

### 18.2.1 자식이 실패하면 모든 자식을 취소하는 코루틴
- 기본 Job 계층 구조에서는 자식 하나가 실패하면 모든 형제 자식이 취소
- 이는 launch, async 기본 동작

```kotlin
fun main(): Unit = runBlocking {
    launch {
        try {
            while (true) {
                println("Heartbeat!")
                delay(500.milliseconds)
            }
        } catch (e: Exception) {
            println("Heartbeat terminated: $e")
            throw e
        }
    }

    launch {
        delay(1.seconds)
        throw UnsupportedOperationException("Ow!")
    }
}
```
- 결과: 형제 코루틴에서 예외 발생 → 하트비트 코루틴도 취소됨

### 18.2.2 구조적 동시성은 코루틴 스코프를 넘는 예외에만 영향을 미친다
- 스코프 내부의 예외는 스코프에 영향을 주지만, try-catch로 감싸면 외부 전파를 막을 수 있음

```kotlin
fun main(): Unit = runBlocking {
    launch {
        try {
            while (true) {
                println("Heartbeat!")
                delay(500.milliseconds)
            }
        } catch (e: Exception) {
            println("Heartbeat terminated: $e")
            throw e
        }
    }

    launch {
        try {
            delay(1.seconds)
            throw UnsupportedOperationException("Ow!")
        } catch (u: UnsupportedOperationException) {
            println("Caught $u")
        }
    }
}
```
- 출력: 예외 발생 후에도 하트비트 계속 작동함

### 18.2.3 슈퍼바이저는 부모와 형제가 취소되지 않게 한다
- 기본 Job 계층에서는 자식 코루틴이 실패하면 형제 코루틴과 부모도 취소
- 반면 SupervisorJob을 사용하면 자식의 실패가 부모나 형제에게 영향을 주지 않음
- 예외 전파는 차단, 구조적 동시성은 유지

```kotlin
fun main(): Unit = runBlocking {
    supervisorScope {
        launch {
            try {
                while (true) {
                    println("Heartbeat!")
                    delay(500.milliseconds)
                }
            } catch (e: Exception) {
                println("Heartbeat terminated: $e")
                throw e
            }
        }

        launch {
            delay(1.seconds)
            throw UnsupportedOperationException("Ow!")
        }
    }
}
```
실행 결과
```text
Heartbeat!
Heartbeat!
Exception in thread "main" ...
Heartbeat!
Heartbeat!
```
- 두 번째 launch에서 예외가 발생하지만, supervisorScope 안에서 실행되었기 때문에 첫 번째 launch는 계속 실행
- 즉, 형제 코루틴이 실패하더라도 다른 형제는 계속 작동 가능

활용 예시
- 서버에서 **백그라운드 감시 작업(하트비트)**이 사용자 작업과 독립적으로 유지되어야 할 때
- UI 구성 요소에서 하나의 요청 실패가 전체 화면을 중단시키지 않도록 할 때

## 18.3 CoroutineExceptionHandler: 예외 처리를 위한 마지막 수단
- 처리되지 않은 예외는 부모 코루틴에 전파됨, 마지막으로 CoroutineExceptionHandler가 처리
- CoroutineExceptionHandler는 launch에서만 동작하며, async에는 적용되지 않음
- 시스템 전역에서 예외를 기록하거나 종료 처리할 때 사용됨

```kotlin
val exceptionHandler = CoroutineExceptionHandler { _, exception ->
    println("[ERROR] ${exception.message}")
}

class ComponentWithScope(dispatcher: CoroutineDispatcher = Dispatchers.Default) {
    private val scope = CoroutineScope(SupervisorJob() + dispatcher + exceptionHandler)

    fun action() = scope.launch {
        throw UnsupportedOperationException("Ouch!")
    }
}

fun main() = runBlocking {
    val supervisor = ComponentWithScope()
    supervisor.action()
    delay(1.seconds)
}
```
출력 결과
```text
[ERROR] Ouch!
```
- launch 내에서 발생한 예외는 CoroutineExceptionHandler로 전달되어 처리
- 코루틴 컨텍스트에 Handler를 명시적으로 넣어야 작동

중간 계층 핸들러의 무시 현상
```kotlin
private val topLevelHandler = CoroutineExceptionHandler { _, e ->
    println("[TOP] ${e.message}")
}
private val intermediateHandler = CoroutineExceptionHandler { _, e ->
    println("[INTERMEDIATE] ${e.message}")
}

fun main() {
    GlobalScope.launch(topLevelHandler) {
        launch(intermediateHandler) {
            throw UnsupportedOperationException("Ouch!")
        }
    }
    Thread.sleep(1000)
}

```
출력 결과
```text
[TOP] Ouch!
```
- 예외가 발생하면 중간 핸들러는 무시되고, 루트(GlobalScope)의 핸들러만 호출
- launch가 아닌 async였으면 전파되지 않음

### 18.3.1 CoroutineExceptionHandler를 launch와 async에 적용할 때 차이점
- launch는 예외가 즉시 전파되며 CoroutineExceptionHandler가 호출
- async는 예외가 **지연 전파(Deferred)**되며, await() 시점에 예외가 발생하므로 CoroutineExceptionHandler가 호출되지 않음

launch 내부에서 async, 핸들러 동작
```kotlin
fun main() = runBlocking {
    val exceptionHandler = CoroutineExceptionHandler { _, e ->
        println("[ERROR] ${e.message}")
    }

    val scope = CoroutineScope(SupervisorJob() + exceptionHandler)

    scope.launch {
        async {
            throw UnsupportedOperationException("Ouch!")
        }
    }

    delay(1.seconds)
}
```
출력 결과
```text
[ERROR] Ouch!
```

최상위 코루틴을 async로 변경 → 핸들러 호출 안 됨
```kotlin
fun main() = runBlocking {
    val exceptionHandler = CoroutineExceptionHandler { _, e ->
        println("[ERROR] ${e.message}")
    }

    val scope = CoroutineScope(SupervisorJob() + exceptionHandler)

    scope.async {
        launch {
            throw UnsupportedOperationException("Ouch!")
        }
    }

    delay(1.seconds)
}
```
출력 결과
```text
// 아무 것도 출력되지 않음
```
- 최상위 코루틴이 async일 경우, 예외는 **Deferred의 소비자(await)**가 처리해야 하며, CoroutineExceptionHandler는 호출되지 않음

## 18.4 플로우에서 예외 처리
- 일반적인 코루틴 함수처럼 Flow도 중간 또는 최종 연산자에서 예외가 발생할 수 있음
- 예외 발생 지점은 대부분 collect 시점이며, try-catch로 감쌀 수 있음
- 복잡한 Flow에서는 catch 연산자를 사용하는 것이 더 깔끔하고 유지보수 쉬움

예외가 발생하는 Flow
```kotlin
class UnhappyFlowException : Exception()

val exceptionalFlow = flow {
    repeat(5) { number -> emit(number) }
    throw UnhappyFlowException()
}
```
- 0~4까지 emit한 후, 예외 발생

예외 처리 with try-catch
```kotlin
fun main() = runBlocking {
    val transformedFlow = exceptionalFlow.map { it * 2 }

    try {
        transformedFlow.collect { print("$it ") }
    } catch (u: UnhappyFlowException) {
        println("\nHandled: $u")
    }
}
```
출력 결과
```text
0 2 4 6 8 
Handled: UnhappyFlowException
```

### 18.4.1 catch 연산자로 업스트림 예외 처리
- catch {} 연산자는 Flow 중간 연산자이며, **앞단(업스트림)**의 예외만 처리 가능
- 다운스트림(onEach, collect 등)에서 발생한 예외는 catch로 잡히지 않음

catch로 기본값 emit
```kotlin
fun main() = runBlocking {
    exceptionalFlow
        .catch { cause ->
            println("\nHandled: $cause")
            emit(-1) // 예외 발생 시 기본값으로 -1 방출
        }
        .collect { print("$it ") }
}
```
출력 결과
```text
0 1 2 3 4 
Handled: UnhappyFlowException
-1
```

catch 다음 onEach에서 발생한 예외는 잡히지 않음
```kotlin
fun main() = runBlocking {
    exceptionalFlow
        .map { it + 1 }
        .catch { cause -> println("\nHandled $cause") }
        .onEach { throw UnhappyFlowException() }
        .collect()
}
```
출력
```text
Exception in thread "main" UnhappyFlowException
```
- 이유: catch는 **앞단(map 등)**에서 발생한 예외만 처리 가능. **뒤(onEach 등)**는 처리 불가

### 18.4.2 줄어가 참일 때 플로우의 수집 재시도: retry 연산자
- 예외 발생 시 retry 조건을 만족하면 Flow 전체를 다시 실행
- catch는 예외를 처리하고 끝이지만, retry는 예외 처리 후 재시도 가능

retry로 재시도 구현
```kotlin
class CommunicationException : Exception("Communication failed!")

val unreliableFlow = flow {
    println("Starting the flow!")
    repeat(10) { number ->
        if (Random.nextDouble() < 0.1) throw CommunicationException()
        emit(number)
    }
}

fun main() = runBlocking {
    unreliableFlow
        .retry(5) { cause ->
            println("\nHandled: $cause")
            cause is CommunicationException
        }
        .collect { number ->
            print("$number ")
        }
}
```
출력
```text
Starting the flow!
0 1 2 3 
Handled: Communication failed!
Starting the flow!
0 1 2 3 4 
Handled: Communication failed!
Starting the flow!
0 1 2 3 4 5 6 7 8 9
```
- retry는 업스트림 연산자까지 전체 재실행
- 따라서 **부수 효과(side effect)**가 있다면 재실행에 주의

**API 통시 중 일시적 오류 발생 시 retry()로 재시도 로직 구현**

## 18.5 코루틴과 플로우 테스트
- 코루틴과 플로우 코드를 테스트하려면 일반적인 테스트 방식 외에 runTest 등 코루틴 전용 테스트 도구가 필요
- runBlocking은 테스트에서 사용 가능하지만, 실제 지연 시간만큼 대기하기 때문에 비효율적
- 가상 시간과 테스트 디스패처를 사용하면 테스트 속도와 신뢰도를 향상시킬 수 있음

### 18.5.1 코루틴을 사용하는 테스트를 빠르게 만들기: 가상 시간과 테스트 디스패처
- runTest는 delay와 같은 코루틴 지연을 가상 시간으로 처리하므로 테스트가 실시간보다 빠르게 수행됨
- runTest는 내부적으로 TestCoroutineScheduler를 사용하여 지연 없이 실행 가능

지연이 있는 테스트도 빠르게 완료
```kotlin
@Test
fun testDelay() = runTest {
    val startTime = System.currentTimeMillis()
    delay(20.seconds)
    println(System.currentTimeMillis() - startTime)
}
```
출력
```text
11
```
- 실제로 20초를 기다리지 않고, 가상 시간으로 처리

코루틴 동시 실행 없이 실패하는 케이스
```kotlin
@Test
fun testDelay() = runTest {
    var x = 0
    launch { x++ }
    launch { x++ }
    assertEquals(2, x) // 실패 가능성 있음
}
```
- runTest는 일시 중단 지점이 없는 launch는 병렬로 실행하지 않음
- 이 경우, 코루틴이 실행되기 전에 assertEquals가 호출될 수 있음

테스트가 성공하기 위해서는
- delay(), yield() 등을 추가
- advanceUntilIdle() 또는 runCurrent()를 호출해 코루틴 실행을 보장

delay와 가상 시계 활용
```kotlin
@OptIn(ExperimentalCoroutinesApi::class)
@Test
fun testDelay() = runTest {
    var x = 0
    launch {
        delay(500.milliseconds)
        x++
    }
    launch {
        delay(1.seconds)
        x++
    }
    println(currentTime) // 0
        
    delay(600.milliseconds)
    assertEquals(1, x)
    println(currentTime) // 600
        
    delay(500.milliseconds)
    assertEquals(2, x)
    println(currentTime) // 1100
}
```

advanceUntilIdle()로 예약된 모든 코루틴 실행
```kotlin
@OptIn(ExperimentalCoroutinesApi::class)
@Test
fun testDelay() = runTest {
    var x = 0
    launch {
        x++
        launch { x++ }
    }
    launch {
        delay(200.milliseconds)
        x++
    }

    runCurrent() // 현재 예약된 코루틴 실행
    assertEquals(2, x)

    advanceUntilIdle() // 예약된 모든 코루틴 실행
    assertEquals(3, x)
}
```

### 18.5.2 터빈으로 플로우 테스트
- runTest를 이용한 플로우 테스트도 가능하지만, 단순한 수집만으로는 발생 순서나 조건에 대한 상세한 검증이 어려움
- 이를 보완하기 위해 Turbine 라이브러리를 사용하면 플로우의 각 emit에 대해 직접적으로 값을 검증하고 제어할 수 있음
- Turbine은 코틀린의 Flow를 테스트하기 위해 만들어진 서드파티 라이브러리. 간결하고 강력한 DSL을 제공

정리
- test {}
  - 플로우를 테스트 환경에서 수집하기 위한 DSL 블록
- awaitItem()
  - 다음 emit 값을 대기 후 반환
- awaitComplete()
  - 플로우 완료를 기다림
- awaitError()
  - 예외 발생 시 검증용
- cancelAndIgnoreRemainingEvents()
  - 이후 이벤트 무시하고 종료

```kotlin
@Test
fun doTest() = runTest {
    val results = myFlow.test {
        assertEquals(1, awaitItem())
        assertEquals(2, awaitItem())
        assertEquals(3, awaitItem())
        awaitComplete()
    }
}
```
- myFlow는 1, 2, 3을 emit하는 Flow
- test 블록 내에서 awaitItem()으로 각 값을 순차적으로 확인
- 마지막엔 awaitComplete()를 호출하여 정상 완료되었는지 검증

API 결과를 emit하는 플로우 테스트
```kotlin
fun getUserFlow(): Flow<User> = flow {
    emit(User("Alice"))
    emit(User("Bob"))
}

@Test
fun testUserFlow() = runTest {
    getUserFlow().test {
        assertEquals("Alice", awaitItem().name)
        assertEquals("Bob", awaitItem().name)
        awaitComplete()
    }
}
```

에러를 발생시키는 플로우
```kotlin
fun errorFlow(): Flow<Int> = flow {
    emit(1)
    throw IllegalStateException("Fail")
}

@Test
fun testErrorFlow() = runTest {
    errorFlow().test {
        assertEquals(1, awaitItem())
        val exception = awaitError()
        assertTrue(exception is IllegalStateException)
        assertEquals("Fail", exception.message)
    }
}
```

UI 상태 변화를 Flow로 표현할 때
```kotlin
val viewModel = MyViewModel()

@Test
fun testUiStateFlow() = runTest {
    viewModel.uiState.test {
        assertEquals(UiState.Loading, awaitItem())
        assertEquals(UiState.Success(data), awaitItem())
        cancelAndIgnoreRemainingEvents()
    }
}
```

터빈
- Flow의 순차적 emit 결과를 확인하고 싶을 때
- 정확한 값, 순서, 완료 여부 등을 검증해야 할 때
- ViewModel, Repository 등에서 상태 플로우를 테스트할 때
- StateFlow, SharedFlow보단 cold flow 기반 테스트에 더 적합
